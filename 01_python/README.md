# はじめてのPython
Pythonに限らず多くのプログラミング言語はシーンによって色々な書き方可能で、「ちょっとやったことがある状態」だと、なにか検索して参考にしようとしたウェブサイトでの書き方の違いに起因して混乱することがよくある（と思われる）。原則的なルールとよく使われる書き方について整理する。

## （ファイル実行モードの）基本的なルール
### 実行は上から
ファイル実行モードでは、実行するファイルの上から処理が行わるのが基本。以下のようなスクリプトが実行されると、xに1が代入されたあと2が代入されるので `x: 2` と出力される。

```
x = 1
x = 2
print("x: ", x) # x: 2
```
なお、PythonではC/C++で `int x;` でxはint型と指定したような型の指定はない。よって、以下のように `x = 1` のあと `x = "abc"` と整数の入っていたxに文字列を入れ直しても良い。ただ、'y = x + 3' の行で、**文字列に1を足す**ができない旨のエラーとなる。簡単にいえば、スクリプト内で辻褄があえばよい（≒整数でも文字列でもprintはできる）が、無理な処理をする（≒文字列に1を足す）とその行でエラーとなる。

```
x = 1
x = "abc"
print("x: ", x) # x: abc
y = x + 3 # ->err
```
### ブロックはインデントで表現する
Pythonではブロックをインデントで表現するため、（特に行頭に）むやみにtabやspaceをいれてはいけない。例えば、次のスクリプトはxが0以上か出力するものであるが、`:` の次の行は一つ分インデントされている。このインデントによって「もし～ならXXする」のXXの範囲を示している。
```
x = 3
if x > 0:
    print("xは0以上です。")
print("判定終わり")
```
次のように書くと `print("判定終わり")` が「もし～ならXXする」のXXに含まれることを意味するので、`x > 0` のときのみ判定終わりと出力されるようになる。
```
x = 3
if x > 0:
    print("xは0以上です。")
    print("判定終わり")
```
次の場合は、「もし～ならXXする」のXXが無いため構文（syntax）エラーとなる。
```
x = 3
if x > 0:
print("xは0以上です。") # ->err
print("判定終わり")
```
他にもインデントによるブロックを用いループや関数などが記述される。次のスクリプトは関数の例。関数は `def` というキーワードを使って定義でき、この例では、`func` という名前の `x` と `y` を受け取り、xのｙ倍を表示するよう実装されている。
```
def func(x, y):
    print(x, "の", y,"倍は", x * y, "です。")

func(3, 4) # 3 の 4 倍は 12 です。
```
なお、前述のようにPythonは上から実行されていくが、 `def` から始まる関数`func`を定義するブロックでは、関数が定義されているだけで関数の実行はなされない。`func(3, 4)`と関数が呼び出される行で初めて実行される。

繰り返すの処理を行うループでは繰り返す内容をブロックで表現することが行われる。次のスクリプトにおいて、`[]`で示されているのは**list**と呼ばれる値の集合（配列）を扱う型。ここでは、`t`に`"abc", "def", "efg"`の三つの文字列が格納されている。
```
t = ["abc", "def", "efg"]
for c in t:
    print(c)
```
`forループ`を使い、`t`に格納される各要素`c`を取り出しているので、このスクリプトを実行すると次の結果が得られる。
>abc  
>def  
>efg

なお、listは値を追加したり書き換えたりと色々な使い方がなされる。`[]`と共に現れる謎の記述※があればlist絡みなので**list python**などで検索してみると良い。

※例えば`t[::2]`など。ちなみにこれはスライス呼ばれる操作で`[beg:end:step]`のように配列のbeg: 何番目からend: 何番目までをstep: 間隔を指定して取り出す書き方。begとendが省略されているので、最初から最後までのstep=2で取り出しているので`['abc', 'efg']`が得られる。

### import
複雑な処理を行おうとすると一つの.pyファイルに色々と書いて行くことになり長く保守のしにくい状態になってしまう。Pythonでは**import**という機能を使って別の.pyファイルに書かれた関数などの機能を読み込むことができるようになっている。
次のスクリプトでは、sample01.pyにおいてutils（.py）をimportしてutils.pyで定義される`func()`を呼び出している。
```
# sample01.py
import utils
utils.func()
```

```
# utils.py
def func():
    print("hello python!")
```
なお、上記の例では、`import utils`とutils全体をimportしてから`utils.func()`と呼び出しを行ったが、次のように特定の機能だけimportすることもできる。
```
# sample01.py
from utils import func
func()
```

また、次のように**as**という記号を使って別名（エイリアス）をつけて使うこともできる。ここでは、importしたfuncに`utils_func`という別名をつけて使うようにしている。既存の関数名など重複する場合などは別名を使って衝突を避ける。
```
# sample01.py
from utils import func as utils_func
utils_func()
```
### `if __name__ == '__main__':`?
GitHubに挙げられているスクリプトなどには`if __name__ == '__main__':`のような書き方をされているスクリプトがある。これは、import時にスクリプトに書かれた内容が実行されてしまうのを避けることを目的としている。

次のようなスクリプトがあったとする。

```
# sample01.py
from utils import func
func()
```

```
# utils.py
def func():
    print("hello python!")
func()
```
utils.pyを実装する際には、utils.py単体で実行して動作などを確認することが行われる（機能毎に整理しながらファイルを分け、適切に動作するか確認しやすい状態を保つために非常に重要な考え方である）。よって、utils.py内にはテスト用の`func()`という関数funcを実行する部分が残っている（し、他者が見たときに機能が理解できるよう残しておくべきである）。

この状態でsample01.pyを実行すると次のように`hello python!`が2回出力される。これは、`from utils import func`を実行する際にutils.py全体も実行されているからである。このように、具体的な実行部分を含むスクリプトをimportすると意図しない挙動をしてしまう。
>hello python!  
>hello python!

`if __name__ == '__main__':`はこういった状態を防ぐために用いられるもの。`__name__`というのはPythonによる予約語で、基本的にはそれの記述されるファイル名（正確にはモジュール名、utils.pyであれば「\_\_util\_\_」）が格納されるが、それが実行したファイルである場合は「\_\_main\_\_」が格納されるよいう仕組みになっている。よって、utils.pyを次のように書いておくと、utils.pyが実行された際にはfunc()が実行されるが、importされる際には実行されない、という切り替えを行うことができる。
```
# utils.py
def func():
    print("hello python!")

if __name__ == '__main__':
    func()
```

Pythonのウェブ教材などではあまりこのあたりの作法にまで言及するものはないようであるが、基本的には実行部分は`if __name__ == '__main__':`の中にいれる書き方をしておくことを推奨する。
